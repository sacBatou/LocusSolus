<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>è›‡è›‡å¤§ä½œæˆ˜ - Slither Battle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #fff; /* ç™½è‰²èƒŒæ™¯ */
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* ç¦ç”¨é€‰ä¸­å’Œé•¿æŒ‰èœå• */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        #gameCanvas {
            display: block;
            /* ç§»é™¤ CSS ä¸­çš„å›ºå®šå®½é«˜ï¼Œå®Œå…¨ç”± JS æ§åˆ¶ä»¥é¿å…å½¢å˜ */
        }
        /* UI å±‚ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* é€‚é…åˆ˜æµ·å±å’Œåº•éƒ¨å°é»‘æ¡ */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            box-sizing: border-box;
        }
        .pointer-events-auto {
            pointer-events: auto;
        }
        
        /* æ‘‡æ†åŒºåŸŸ - å·²éšè— */
        #joystick-zone {
            display: none; 
        }

        ::-webkit-scrollbar {
            display: none;
        }

        .cooldown-overlay {
            transition: height 0.1s linear;
        }
        
        .glass-panel {
            background: rgba(20, 20, 30, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <!-- æ¸¸æˆç”»å¸ƒ -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI å±‚ -->
    <div id="uiLayer" class="ui-layer hidden">
        
        <!-- å·¦ä¸Šè§’ä¿¡æ¯ï¼šæ—¶é—´ -->
        <!-- å¢åŠ  top/left è¾¹è·ï¼Œé¿å…è´´è¾¹ -->
        <div class="absolute top-6 left-6 md:top-4 md:left-4 text-gray-800 text-xl font-bold drop-shadow-sm bg-white/50 px-3 py-1 rounded-full border border-gray-300 pointer-events-none select-none">
            â±ï¸ <span id="timerDisplay">05:00</span>
        </div>

        <!-- å³ä¸Šè§’æ’è¡Œæ¦œ -->
        <!-- å¢åŠ  top/right è¾¹è· -->
        <div class="absolute top-6 right-6 md:top-4 md:right-4 w-40 md:w-48 bg-black/60 rounded-lg p-2 text-white pointer-events-auto backdrop-blur-sm shadow-lg select-none">
            <h3 class="text-center text-sm font-bold text-yellow-400 mb-1 border-b border-white/20 pb-1">ğŸ† æ’è¡Œæ¦œ</h3>
            <ul id="leaderboard" class="text-xs space-y-1">
                <!-- åŠ¨æ€ç”Ÿæˆ -->
            </ul>
            <div class="mt-2 pt-1 border-t border-white/20 text-xs text-center text-gray-300">
                ä½ çš„ç§¯åˆ†: <span id="myScore" class="font-bold text-white">0</span>
            </div>
        </div>

        <!-- è™šæ‹Ÿæ‘‡æ† (å·²éšè—) -->
        <div id="joystick-zone"></div>

        <!-- åŠ é€ŸæŒ‰é’® (å³ä¸‹) -->
        <!-- å¢åŠ  bottom/right è¾¹è·ï¼Œé˜²æ­¢è¢«éƒ¨åˆ†æ‰‹æœºæµè§ˆå™¨çš„åº•éƒ¨æ é®æŒ¡ -->
        <div class="absolute bottom-16 right-8 md:bottom-10 md:right-10 pointer-events-auto">
            <button id="boostBtn" class="relative w-20 h-20 rounded-full bg-red-500 border-4 border-red-700 shadow-xl active:scale-95 transition-transform overflow-hidden flex items-center justify-center group touch-manipulation">
                <span class="text-2xl text-white">âš¡</span>
                <!-- å†·å´é®ç½© -->
                <div id="boostCooldown" class="absolute bottom-0 left-0 w-full h-0 bg-black/60 z-10"></div>
            </button>
        </div>
    </div>

    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-50 bg-gray-100 bg-[url('https://images.unsplash.com/photo-1614726365723-49cfae974e30?q=80&w=2666&auto=format&fit=crop')] bg-cover bg-center">
        <div class="absolute inset-0 bg-white/30 backdrop-blur-md"></div>
        <div class="glass-panel p-8 rounded-2xl w-full max-w-md mx-4 text-center relative z-10 transform transition-all shadow-2xl border-gray-500/30 !bg-white/90 !text-gray-800">
            <h1 class="text-4xl md:text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-green-500 to-blue-600 mb-2">è›‡è›‡å¤§ä½œæˆ˜</h1>
            <p class="text-gray-500 mb-8 text-sm">çµæ´»èµ°ä½ï¼Œåå™¬è¿›åŒ–ï¼Œæˆä¸ºéœ¸ä¸»ï¼</p>

            <div class="space-y-4 mb-8 text-left">
                <div>
                    <label class="block text-gray-700 text-sm font-bold mb-2">æ¸¸æˆæ—¶é•¿ (åˆ†é’Ÿ)</label>
                    <input type="number" id="inputTime" value="5" min="1" max="30" class="w-full bg-gray-100 border border-gray-300 text-gray-800 rounded px-3 py-2 focus:outline-none focus:border-green-500 transition-colors">
                </div>
                <div>
                    <label class="block text-gray-700 text-sm font-bold mb-2">AI æ•°é‡ (1-50)</label>
                    <input type="number" id="inputAI" value="10" min="0" max="50" class="w-full bg-gray-100 border border-gray-300 text-gray-800 rounded px-3 py-2 focus:outline-none focus:border-green-500 transition-colors">
                </div>
            </div>

            <button id="startBtn" class="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-400 hover:to-emerald-500 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-200 text-lg">
                å¼€å§‹æ¸¸æˆ
            </button>
        </div>
    </div>

    <!-- ç»“ç®—ç•Œé¢ -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-50 bg-black/50 backdrop-blur-md">
        <div class="glass-panel p-8 rounded-2xl w-full max-w-lg mx-4 text-center !bg-white/95 !text-gray-800">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">â±ï¸ æ¸¸æˆç»“æŸ</h2>
            
            <div class="bg-gray-100 rounded-xl p-4 mb-6 max-h-60 overflow-y-auto border border-gray-200">
                <table class="w-full text-left text-sm">
                    <thead class="text-gray-500 border-b border-gray-300">
                        <tr>
                            <th class="pb-2">æ’å</th>
                            <th class="pb-2">ç©å®¶</th>
                            <th class="pb-2 text-right">æœ€ç»ˆå¾—åˆ†</th>
                        </tr>
                    </thead>
                    <tbody id="finalRanking" class="text-gray-800">
                        <!-- åŠ¨æ€ç”Ÿæˆ -->
                    </tbody>
                </table>
            </div>

            <button id="restartBtn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full shadow-lg transform hover:scale-105 transition-all">
                è¿”å›ä¸»èœå•
            </button>
        </div>
    </div>

    <script>
        /**
         * æ¸¸æˆå¸¸é‡ä¸å…¨å±€å˜é‡
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // æ¸¸æˆé…ç½®
        const CONFIG = {
            mapWidth: 4000,
            mapHeight: 4000,
            baseSpeed: 3,
            boostSpeed: 6,
            turnSpeed: 0.08,
            startLength: 10,
            segmentDist: 10,
            snakeRadius: 15,
            foodRadius: 6,
            foodValue: 1,
            foodCount: 800, 
            boostCooldown: 10000,
            boostDuration: 2000,
            boostActiveTime: 3000 
        };

        // é¢œè‰²åº“
        const COLORS = [
            '#FF5252', '#E040FB', '#7C4DFF', '#536DFE', '#448AFF', 
            '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE', '#B2FF59', 
            '#EEFF41', '#EFD600', '#FFD740', '#FFAB40', '#FF6E40'
        ];

        // çœŸå®æ„Ÿåå­—åº“
        const AI_NAMES = [
            "Venom", "Slayer", "Viper", "Ghost", "Shadow", 
            "Hunter", "Cobra", "Rex", "Storm", "Blaze", 
            "Titan", "Hydra", "Phantom", "Reaper", "Nova", 
            "Drago", "Frost", "Spark", "Raven", "Wolf",
            "Neon", "Cyber", "Pixel", "Glitch", "Echo"
        ];

        // çŠ¶æ€
        let gameState = 'START';
        let lastTime = 0;
        let gameTimeRemaining = 0;
        let animationId;
        
        // å®ä½“
        let player;
        let enemies = [];
        let foods = [];

        // è¾“å…¥
        const input = {
            angle: 0,
            active: false,
            boost: false,
            isMouseDown: false // æ–°å¢ï¼šè®°å½•é¼ æ ‡æ˜¯å¦æŒ‰ä¸‹
        };

        // DOM å…ƒç´ 
        const uiLayer = document.getElementById('uiLayer');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const timerDisplay = document.getElementById('timerDisplay');
        const myScoreDisplay = document.getElementById('myScore');
        const leaderboardList = document.getElementById('leaderboard');
        const boostBtn = document.getElementById('boostBtn');
        const boostCooldownOverlay = document.getElementById('boostCooldown');
        const inputTime = document.getElementById('inputTime');
        const inputAI = document.getElementById('inputAI');
        const finalRankingBody = document.getElementById('finalRanking');

        /**
         * å·¥å…·å‡½æ•°
         */
        function rand(min, max) { return Math.random() * (max - min) + min; }
        function randColor() { return COLORS[Math.floor(Math.random() * COLORS.length)]; }
        function getDistance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
        
        /**
         * ç±»å®šä¹‰
         */
        
        class Food {
            constructor(x, y, value = 1, color = null) {
                this.x = x || rand(20, CONFIG.mapWidth - 20);
                this.y = y || rand(20, CONFIG.mapHeight - 20);
                this.radius = CONFIG.foodRadius + (value > 1 ? 2 : 0);
                this.color = color || randColor();
                this.value = value;
                this.floatOffset = Math.random() * Math.PI * 2; 
            }

            draw(ctx, viewX, viewY) {
                if (this.x < viewX - 20 || this.x > viewX + canvas.width + 20 ||
                    this.y < viewY - 20 || this.y > viewY + canvas.height + 20) return;

                const pulse = Math.sin(Date.now() / 200 + this.floatOffset) * 1;
                ctx.beginPath();
                ctx.arc(this.x - viewX, this.y - viewY, this.radius + pulse, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        class Snake {
            constructor(name, isPlayer = false) {
                this.name = name; 
                this.isPlayer = isPlayer;
                
                // --- é¢œè‰²å›ºå®šé€»è¾‘ ---
                // åœ¨åˆ›å»ºæ—¶å°±ç¡®å®šé¢œè‰²ï¼ŒResetæ—¶ä¸å†éšæœºç”Ÿæˆ
                this.color = this.isPlayer ? '#00E676' : randColor();
                this.headColor = this.isPlayer ? '#F0F0F0' : '#FFEEEE';

                this.reset();
            }

            reset() {
                this.x = rand(200, CONFIG.mapWidth - 200);
                this.y = rand(200, CONFIG.mapHeight - 200);
                this.angle = rand(0, Math.PI * 2);
                this.targetAngle = this.angle;
                this.speed = CONFIG.baseSpeed;
                this.score = 0;
                this.radius = CONFIG.snakeRadius;
                
                // æ³¨æ„ï¼šè¿™é‡Œåˆ é™¤äº†é¢œè‰²é‡ç½®çš„ä»£ç ï¼Œä¿æŒæ„é€ å‡½æ•°ä¸­çš„é¢œè‰²
                
                this.dead = false;
                
                this.isBoosting = false;
                this.boostTimer = 0;
                this.cooldownTimer = 0; 

                this.body = [];
                for(let i = 0; i < CONFIG.startLength; i++) {
                    this.body.push({ x: this.x, y: this.y });
                }
                
                // ä¿®å¤AIæ­»äº¡æ˜¾ç¤ºçš„BUGï¼šæ¸…ç©ºè·¯å¾„å†å²ï¼Œé˜²æ­¢ç»˜åˆ¶å‡ºè¿æ¥æ—§ä½ç½®çš„çº¿æ¡
                this.path = []; 
                this.path.push({x: this.x, y: this.y});
                
                // AI çŠ¶æ€
                this.aiThinkTimer = 0;
                this.wanderAngle = this.angle; // æœŸæœ›çš„æ¸¸è¡/è§…é£Ÿæ–¹å‘
            }

            update(dt) {
                if (this.dead) return;

                if (this.isBoosting) {
                    this.boostTimer -= dt;
                    if (this.boostTimer <= 0) {
                        this.isBoosting = false;
                        this.speed = CONFIG.baseSpeed;
                        this.cooldownTimer = CONFIG.boostCooldown; 
                    }
                } else if (this.cooldownTimer > 0) {
                    this.cooldownTimer -= dt;
                    if (this.cooldownTimer < 0) this.cooldownTimer = 0;
                }

                if (this.isPlayer) {
                    if (input.active) {
                        this.targetAngle = input.angle;
                    }
                } else {
                    this.updateAI(dt);
                }

                let diff = this.targetAngle - this.angle;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                
                if (Math.abs(diff) < CONFIG.turnSpeed) {
                    this.angle = this.targetAngle;
                } else {
                    this.angle += Math.sign(diff) * CONFIG.turnSpeed;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;

                // è¾¹ç•Œåå¼¹
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.angle = Math.PI - this.angle;
                    this.targetAngle = this.angle;
                    this.wanderAngle = this.angle; 
                } else if (this.x > CONFIG.mapWidth - this.radius) {
                    this.x = CONFIG.mapWidth - this.radius;
                    this.angle = Math.PI - this.angle;
                    this.targetAngle = this.angle;
                    this.wanderAngle = this.angle;
                }
                
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.angle = -this.angle;
                    this.targetAngle = this.angle;
                    this.wanderAngle = this.angle;
                } else if (this.y > CONFIG.mapHeight - this.radius) {
                    this.y = CONFIG.mapHeight - this.radius;
                    this.angle = -this.angle;
                    this.targetAngle = this.angle;
                    this.wanderAngle = this.angle;
                }

                let head = { x: this.x, y: this.y };
                let previous = { x: this.x, y: this.y };
                let newBody = [previous];
                
                for (let i = 0; i < this.body.length; i++) {
                    let curr = this.body[i];
                    let target = i === 0 ? {x: this.x, y: this.y} : newBody[i];
                    
                    let dist = getDistance(curr.x, curr.y, target.x, target.y);
                    
                    if (dist > 0) {
                        let dx = curr.x - target.x;
                        let dy = curr.y - target.y;
                        let angle = Math.atan2(dy, dx);
                        
                        let nx = target.x + Math.cos(angle) * CONFIG.segmentDist;
                        let ny = target.y + Math.sin(angle) * CONFIG.segmentDist;
                        
                        newBody.push({ x: nx, y: ny });
                    } else {
                         newBody.push(curr);
                    }
                }
                
                this.body = newBody.slice(1); 
                
                this.path = this.path || [];
                this.path.unshift({x: this.x, y: this.y});
                
                const neededLength = (this.score + CONFIG.startLength) * CONFIG.segmentDist / 2; 
                if (this.path.length > neededLength + 50) {
                    this.path.pop();
                }
            }
            
            getRenderPoints() {
                let points = [];
                let currentDist = 0;
                let pathIdx = 0;
                
                if (!this.path || this.path.length === 0) return [{x:this.x, y:this.y}];

                points.push(this.path[0]); 

                let totalSegments = CONFIG.startLength + this.score;
                
                for (let i = 0; i < totalSegments; i++) {
                    let lastP = points[points.length - 1];
                    
                    while(pathIdx < this.path.length) {
                        let p = this.path[pathIdx];
                        let d = getDistance(lastP.x, lastP.y, p.x, p.y);
                        if (d >= CONFIG.segmentDist) {
                            points.push(p);
                            break;
                        }
                        pathIdx++;
                    }
                }
                this.body = points;
                return points;
            }

            activateBoost() {
                if (this.cooldownTimer <= 0 && !this.isBoosting) {
                    this.isBoosting = true;
                    this.speed = CONFIG.boostSpeed;
                    this.boostTimer = CONFIG.boostActiveTime;
                }
            }

            // --- å…¨æ–°å‡çº§çš„AIé€»è¾‘ï¼šçŸ¢é‡æ–¥åŠ›åœº ---
            updateAI(dt) {
                this.aiThinkTimer -= dt;
                
                // 1. å¯»æ‰¾é£Ÿç‰©ä¸æ¸¸è¡ (ä½é¢‘å†³ç­–ï¼Œå†³å®š"æƒ³å»å“ª")
                if (this.aiThinkTimer <= 0) {
                    this.aiThinkTimer = 150; // æ¯0.15ç§’æ›´æ–°ä¸€æ¬¡è§…é£Ÿç›®æ ‡
                    
                    let bestFood = null;
                    let minScore = -Infinity; 
                    
                    // è§†é‡å†…çš„é£Ÿç‰©
                    for (let f of foods) {
                        let dist = getDistance(this.x, this.y, f.x, f.y);
                        if (dist > 600) continue;
                        
                        let angleToFood = Math.atan2(f.y - this.y, f.x - this.x);
                        let angleDiff = Math.abs(angleToFood - this.angle);
                        while (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                        
                        // è¯„åˆ†ï¼šè·ç¦»è¶Šè¿‘è¶Šå¥½ï¼Œè§’åº¦åç¦»è¶Šå°è¶Šå¥½
                        let score = (f.value * 50) - dist - (angleDiff * 100); 
                        
                        if (score > minScore) {
                            minScore = score;
                            bestFood = f;
                        }
                    }
                    
                    if (bestFood) {
                        this.wanderAngle = Math.atan2(bestFood.y - this.y, bestFood.x - this.x);
                    } else {
                        // éšæœºæ¸¸è¡ï¼Œå¹³æ»‘æ”¹å˜è§’åº¦
                        if (Math.random() < 0.1) {
                            this.wanderAngle += rand(-1, 1);
                        }
                    }
                }

                // 2. çŸ¢é‡æ–¥åŠ›åœºé¿éšœ (æ¯å¸§è®¡ç®—ï¼Œå†³å®š"èƒ½å»å“ª")
                // å°†æ‰€æœ‰éšœç¢ç‰©è§†ä¸ºæ–¥åŠ›æºï¼Œè®¡ç®—åˆåŠ›æ–¹å‘
                
                const detectionRange = 250; // å¨èƒæ„ŸçŸ¥èŒƒå›´
                const wallMargin = 150;     // å¢™å£æ„ŸçŸ¥è·ç¦»
                
                let avoidX = 0;
                let avoidY = 0;
                let hasThreat = false;

                // A. å¢™å£æ–¥åŠ›
                if (this.x < wallMargin) { avoidX += (wallMargin - this.x) * 5; hasThreat = true; }
                if (this.x > CONFIG.mapWidth - wallMargin) { avoidX -= (this.x - (CONFIG.mapWidth - wallMargin)) * 5; hasThreat = true; }
                if (this.y < wallMargin) { avoidY += (wallMargin - this.y) * 5; hasThreat = true; }
                if (this.y > CONFIG.mapHeight - wallMargin) { avoidY -= (this.y - (CONFIG.mapHeight - wallMargin)) * 5; hasThreat = true; }

                // B. ç”Ÿç‰©æ–¥åŠ›
                let allSnakes = [player, ...enemies];
                for (let s of allSnakes) {
                    if (s === this || s.dead) continue;
                    if (getDistance(this.x, this.y, s.x, s.y) > detectionRange * 2) continue; 

                    // æ£€æŸ¥å¯¹æ–¹èº«ä½“èŠ‚ç‚¹
                    // ä¼˜åŒ–ï¼šéš”ç‚¹æ£€æŸ¥ä»¥æå‡æ€§èƒ½
                    for (let i = 0; i < s.body.length; i += 3) {
                        let p = s.body[i];
                        let dist = getDistance(this.x, this.y, p.x, p.y);
                        
                        if (dist < detectionRange) {
                            // è®¡ç®—æ–¥åŠ›å‘é‡ï¼šä»éšœç¢æŒ‡å‘è‡ªå·±
                            let pushX = this.x - p.x;
                            let pushY = this.y - p.y;
                            
                            // å½’ä¸€åŒ–
                            let len = Math.hypot(pushX, pushY);
                            if (len === 0) len = 0.01;
                            pushX /= len;
                            pushY /= len;
                            
                            // æƒé‡ï¼šè·ç¦»è¶Šè¿‘ï¼Œæ–¥åŠ›å‘ˆæŒ‡æ•°çº§å¢é•¿
                            let weight = Math.pow((detectionRange - dist) / detectionRange, 2) * 150; 
                            
                            avoidX += pushX * weight;
                            avoidY += pushY * weight;
                            
                            // æåº¦å±é™©åˆ¤å®šï¼šå¦‚æœè·ç¦»æè¿‘ä¸”åœ¨æ­£å‰æ–¹
                            if (dist < s.radius + this.radius + 60) {
                                let angleToObs = Math.atan2(p.y - this.y, p.x - this.x);
                                let angleDiff = Math.abs(angleToObs - this.angle);
                                while (angleDiff > Math.PI) angleDiff = Math.PI*2 - angleDiff;
                                
                                if (angleDiff < Math.PI / 2) {
                                     hasThreat = true;
                                }
                            }
                        }
                    }
                }

                // C. åˆåŠ›è®¡ç®—
                if (hasThreat || Math.abs(avoidX) > 1 || Math.abs(avoidY) > 1) {
                    // å¦‚æœæœ‰å¨èƒï¼Œå¼€å¯åŠ é€Ÿ
                    if (hasThreat) this.activateBoost();

                    // æœŸæœ›æ–¹å‘å‘é‡ (æƒé‡è¾ƒå°ï¼Œä¿è¯é¿éšœä¼˜å…ˆ)
                    let desiredX = Math.cos(this.wanderAngle) * 40; 
                    let desiredY = Math.sin(this.wanderAngle) * 40;
                    
                    // æœ€ç»ˆæ–¹å‘ = æœŸæœ› + æ–¥åŠ›
                    let finalX = desiredX + avoidX;
                    let finalY = desiredY + avoidY;
                    
                    this.targetAngle = Math.atan2(finalY, finalX);
                    // é¡ºä¾¿æ›´æ–° wanderAngleï¼Œé˜²æ­¢å¨èƒä¸€æ¶ˆå¤±å°±ç«‹åˆ»å›å¤´æ’æ­»
                    this.wanderAngle = this.targetAngle; 
                } else {
                    // æ— å¨èƒï¼Œå¹³æ»‘è½¬å‘è§…é£Ÿç›®æ ‡
                    this.targetAngle = this.wanderAngle;
                }
            }

            draw(ctx, viewX, viewY) {
                const points = this.getRenderPoints();
                if (points.length === 0) return;

                for (let i = points.length - 1; i >= 0; i--) {
                    let p = points[i];
                    
                    if (p.x < viewX - 50 || p.x > viewX + canvas.width + 50 ||
                        p.y < viewY - 50 || p.y > viewY + canvas.height + 50) continue;

                    ctx.beginPath();
                    ctx.arc(p.x - viewX, p.y - viewY, this.radius, 0, Math.PI * 2);
                    
                    if (i === 0) {
                         ctx.fillStyle = this.headColor;
                    } else {
                         ctx.fillStyle = this.color;
                    }
                    
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; // åŠ æ·±æè¾¹ä»¥ä¾¿åœ¨ç™½åº•çœ‹æ¸…
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                let head = points[0];
                if (head.x > viewX - 50 && head.x < viewX + canvas.width + 50 &&
                    head.y > viewY - 50 && head.y < viewY + canvas.height + 50) {
                    
                    let eyeOffset = 8;
                    let eyeSize = 4;
                    let eyeX1 = head.x + Math.cos(this.angle - 0.5) * eyeOffset;
                    let eyeY1 = head.y + Math.sin(this.angle - 0.5) * eyeOffset;
                    let eyeX2 = head.x + Math.cos(this.angle + 0.5) * eyeOffset;
                    let eyeY2 = head.y + Math.sin(this.angle + 0.5) * eyeOffset;

                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black'; // çœ¼ç›æè¾¹
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(eyeX1 - viewX, eyeY1 - viewY, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(eyeX2 - viewX, eyeY2 - viewY, eyeSize, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(eyeX1 - viewX, eyeY1 - viewY, eyeSize/2, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(eyeX2 - viewX, eyeY2 - viewY, eyeSize/2, 0, Math.PI * 2); ctx.fill();

                    // ç»˜åˆ¶åå­— (æ·±è‰²å­—ä½“ä»¥é€‚åº”ç™½è‰²èƒŒæ™¯)
                    ctx.fillStyle = '#333'; 
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.name + ` (${this.score})`, head.x - viewX, head.y - viewY - 25);
                }
            }
        }

        /**
         * æ¸¸æˆä¸»é€»è¾‘
         */

        function initGame() {
            let timeSet = parseInt(inputTime.value) || 5;
            let aiCount = parseInt(inputAI.value) || 5;
            
            gameTimeRemaining = timeSet * 60; 
            
            player = new Snake("You", true);
            enemies = [];
            
            // éšæœºç”Ÿæˆä¸é‡å¤çš„åå­—
            let availableNames = [...AI_NAMES];
            // æ´—ç‰Œ
            availableNames.sort(() => Math.random() - 0.5);
            
            for(let i=0; i<aiCount; i++) {
                let name = availableNames[i % availableNames.length];
                // å¦‚æœAIå¤ªå¤šåå­—ä¸å¤Ÿç”¨ï¼Œå°±åŠ æ•°å­—åç¼€
                if (i >= availableNames.length) name += ` ${Math.floor(i/availableNames.length) + 1}`;
                enemies.push(new Snake(name));
            }
            
            foods = [];
            for(let i=0; i<CONFIG.foodCount; i++) {
                foods.push(new Food());
            }

            gameState = 'PLAYING';
            lastTime = performance.now();
            
            uiLayer.classList.remove('hidden');
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            resize();
            
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop(lastTime);
        }

        function gameLoop(timestamp) {
            if (gameState !== 'PLAYING') return;

            let dt = timestamp - lastTime;
            lastTime = timestamp;

            if (dt > 100) dt = 100;

            update(dt);
            draw();

            animationId = requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            if (gameTimeRemaining > 0) {
                gameTimeRemaining -= dt / 1000;
                let mins = Math.floor(gameTimeRemaining / 60);
                let secs = Math.floor(gameTimeRemaining % 60);
                timerDisplay.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                
                if (gameTimeRemaining <= 0) {
                    endGame();
                    return;
                }
            }

            player.update(dt);
            enemies.forEach(e => e.update(dt));

            if (player.cooldownTimer > 0) {
                let pct = (player.cooldownTimer / CONFIG.boostCooldown) * 100;
                boostCooldownOverlay.style.height = `${pct}%`;
            } else if (player.isBoosting) {
                boostCooldownOverlay.style.height = '0%';
                boostBtn.classList.add('ring-4', 'ring-yellow-300');
            } else {
                boostCooldownOverlay.style.height = '0%';
                boostBtn.classList.remove('ring-4', 'ring-yellow-300');
            }

            let allSnakes = [player, ...enemies];
            let activeSnakes = allSnakes.filter(s => !s.dead);

            activeSnakes.forEach(snake => {
                for (let i = foods.length - 1; i >= 0; i--) {
                    let f = foods[i];
                    if (getDistance(snake.x, snake.y, f.x, f.y) < snake.radius + f.radius) {
                        snake.score += f.value;
                        foods.splice(i, 1);
                        if (foods.length < CONFIG.foodCount) {
                            foods.push(new Food());
                        }
                    }
                }
            });

            activeSnakes.forEach(s1 => {
                activeSnakes.forEach(s2 => {
                    if (s1 === s2) return; 

                    let collision = false;
                    let points2 = s2.body; 
                    
                    for (let p of points2) {
                        if (getDistance(s1.x, s1.y, p.x, p.y) < s1.radius + s2.radius - 5) {
                            collision = true;
                            break;
                        }
                    }

                    if (collision) {
                        handleDeath(s1);
                    }
                });
            });

            updateLeaderboard(activeSnakes);
            myScoreDisplay.innerText = player.score;
        }

        function handleDeath(snake) {
            // å…³é”®ï¼šé˜²æ­¢åŒä¸€å¸§è¢«å¤šæ¬¡æ€æ­»ï¼Œæˆ–æ­»åç»§ç»­è§¦å‘é€»è¾‘
            if (snake.dead) return;
            snake.dead = true;
            
            let points = snake.body || [];
            points.forEach((p, idx) => {
                if (idx % 2 === 0) {
                    let val = Math.max(1, Math.floor(snake.score / points.length * 2));
                    foods.push(new Food(p.x + rand(-10, 10), p.y + rand(-10, 10), val, snake.color));
                }
            });

            setTimeout(() => {
                if (gameState === 'PLAYING') {
                    snake.reset();
                }
            }, 1000);
        }

        function updateLeaderboard(snakes) {
            let sorted = [...snakes].sort((a, b) => b.score - a.score);
            let top5 = sorted.slice(0, 5);
            
            let html = '';
            top5.forEach((s, index) => {
                let isMe = s === player ? 'text-green-400 font-bold' : 'text-gray-300';
                html += `<li class="flex justify-between ${isMe}"><span>${index+1}. ${s.name}</span><span>${s.score}</span></li>`;
            });
            leaderboardList.innerHTML = html;
        }

        function draw() {
            // èƒŒæ™¯è®¾ä¸ºç™½è‰²
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let viewX = player.x - canvas.width / 2;
            let viewY = player.y - canvas.height / 2;

            drawGrid(viewX, viewY);

            // è¾¹ç•Œé¢œè‰²
            ctx.strokeStyle = '#FF5252';
            ctx.lineWidth = 5;
            ctx.strokeRect(0 - viewX, 0 - viewY, CONFIG.mapWidth, CONFIG.mapHeight);

            foods.forEach(f => f.draw(ctx, viewX, viewY));

            enemies.forEach(e => {
                if (!e.dead) e.draw(ctx, viewX, viewY);
            });

            if (!player.dead) {
                player.draw(ctx, viewX, viewY);
            }
        }

        function drawGrid(vx, vy) {
            // é»‘çº¿ç½‘æ ¼ (åŠé€æ˜ä»¥é˜²å¤ªåˆºçœ¼)
            ctx.strokeStyle = 'rgba(0,0,0,0.15)'; 
            ctx.lineWidth = 1;
            const gridSize = 20; // ä¿æŒå°æ–¹æ ¼å°ºå¯¸
            
            let startX = Math.floor(vx / gridSize) * gridSize;
            let startY = Math.floor(vy / gridSize) * gridSize;

            ctx.beginPath();
            for (let x = startX; x < vx + canvas.width + gridSize; x += gridSize) {
                ctx.moveTo(x - vx, 0);
                ctx.lineTo(x - vx, canvas.height);
            }
            for (let y = startY; y < vy + canvas.height + gridSize; y += gridSize) {
                ctx.moveTo(0, y - vy);
                ctx.lineTo(canvas.width, y - vy);
            }
            ctx.stroke();
        }

        function endGame() {
            gameState = 'GAMEOVER';
            uiLayer.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');

            let allSnakes = [player, ...enemies];
            let sorted = allSnakes.sort((a, b) => b.score - a.score);
            
            let html = '';
            sorted.forEach((s, index) => {
                let rowClass = s === player ? 'bg-green-100 font-bold' : (index % 2 === 0 ? 'bg-gray-50' : '');
                html += `
                    <tr class="${rowClass} border-b border-gray-200">
                        <td class="py-2 pl-2">${index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : index + 1}</td>
                        <td class="py-2">${s.name}</td>
                        <td class="py-2 pr-2 text-right">${s.score}</td>
                    </tr>
                `;
            });
            finalRankingBody.innerHTML = html;
        }

        /**
         * è¾“å…¥ä¸äº‹ä»¶å¤„ç†
         */
        
        // --- PCç«¯é¼ æ ‡æ§åˆ¶é€»è¾‘ä¿®æ”¹ ---
        
        function updateMouseDirection(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // ç›¸å¯¹äºå±å¹•ä¸­å¿ƒè®¡ç®—è§’åº¦
            const dx = mouseX - canvas.width / 2;
            const dy = mouseY - canvas.height / 2;
            input.angle = Math.atan2(dy, dx);
            input.active = true;
        }

        // é¼ æ ‡æŒ‰ä¸‹ï¼šå¼€å§‹è·Ÿéš
        canvas.addEventListener('mousedown', (e) => {
            if (gameState !== 'PLAYING') return;
            // å¦‚æœç‚¹åˆ°çš„æ˜¯åŠ é€ŸæŒ‰é’®ï¼Œä¸è§¦å‘æ–¹å‘æ§åˆ¶
            if (e.target.closest('#boostBtn')) return;
            
            input.isMouseDown = true;
            updateMouseDirection(e);
        });

        // é¼ æ ‡ç§»åŠ¨ï¼šä»…åœ¨æŒ‰ä¸‹æ—¶è·Ÿéš
        canvas.addEventListener('mousemove', (e) => {
            if (gameState !== 'PLAYING') return;
            if (input.isMouseDown) {
                updateMouseDirection(e);
            }
        });

        // é¼ æ ‡æ¾å¼€/ç§»å‡ºï¼šåœæ­¢è·Ÿéš
        const handleMouseUp = () => {
            input.isMouseDown = false;
            // æ¾å¼€åï¼Œinput.active ä¿æŒ trueï¼Œä½† angle ä¸å†æ›´æ–°
            // è›‡ä¼šä¿æŒæœ€åçš„æ–¹å‘ç»§ç»­ç§»åŠ¨
        };

        canvas.addEventListener('mouseup', handleMouseUp);
        // é¼ æ ‡ç§»å‡ºç”»å¸ƒä¹Ÿè§†ä¸ºæ¾å¼€ï¼Œé˜²æ­¢å¡ä½
        canvas.addEventListener('mouseleave', handleMouseUp);


        // --- ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶é€»è¾‘ (ä¿æŒä¸å˜) ---
        // è§¦æ‘¸è·Ÿéšï¼šæ”¹ä¸ºâ€œéšå½¢åŠ¨æ€æ‘‡æ†â€æ¨¡å¼
        // é€»è¾‘ï¼šæŒ‰ä¸‹ä½ç½®ä¸ºæ‘‡æ†ä¸­å¿ƒï¼Œæ»‘åŠ¨åç§»é‡æ§åˆ¶æ–¹å‘
        let joystick = {
            id: null,
            startX: 0,
            startY: 0,
            active: false
        };

        canvas.addEventListener('touchstart', (e) => {
             if (gameState !== 'PLAYING') return;
             // å¦‚æœç‚¹å‡»çš„æ˜¯åŠ é€ŸæŒ‰é’®ï¼Œä¸è§¦å‘ç§»åŠ¨æ‘‡æ†é€»è¾‘
             if (e.target.closest('#boostBtn')) return;

             // åªå¤„ç†ç¬¬ä¸€ä¸ªè§¦æ‘¸ä½œä¸ºæ‘‡æ†
             if (!joystick.active) {
                 const touch = e.changedTouches[0];
                 joystick.id = touch.identifier;
                 joystick.startX = touch.clientX;
                 joystick.startY = touch.clientY;
                 joystick.active = true;
                 input.active = true;
             }
        }, {passive: false});

        canvas.addEventListener('touchmove', (e) => {
            if (gameState !== 'PLAYING' || !joystick.active) return;
            e.preventDefault(); // é˜²æ­¢å±å¹•æ»šåŠ¨

            for(let i=0; i<e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === joystick.id) {
                    const dx = touch.clientX - joystick.startX;
                    const dy = touch.clientY - joystick.startY;
                    
                    // åªæœ‰æ»‘åŠ¨ä¸€å®šè·ç¦»(æ­»åŒº)æ‰æ”¹å˜æ–¹å‘ï¼Œé˜²æ­¢è¯¯è§¦æŠ–åŠ¨
                    if (dx*dx + dy*dy > 25) {
                        input.angle = Math.atan2(dy, dx);
                    }
                    break;
                }
            }
        }, {passive: false});

        const handleTouchEnd = (e) => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystick.id) {
                    joystick.active = false;
                    joystick.id = null;
                    break;
                }
            }
        };
        
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);

        const handleBoostStart = (e) => {
            e.preventDefault();
            e.stopPropagation(); 
            if (player && !player.dead) player.activateBoost();
        };
        
        boostBtn.addEventListener('mousedown', handleBoostStart);
        boostBtn.addEventListener('touchstart', handleBoostStart, {passive: false});
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState === 'PLAYING') {
                if (player && !player.dead) player.activateBoost();
            }
        });

        document.getElementById('startBtn').addEventListener('click', initGame);
        
        document.getElementById('restartBtn').addEventListener('click', () => {
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            ctx.clearRect(0,0,canvas.width, canvas.height);
        });

        function resize() {
            // è·å–å®é™…è§†å£å°ºå¯¸
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // è®¾ç½® canvas å†…éƒ¨ç»˜å›¾åˆ†è¾¨ç‡ (buffer size)
            canvas.width = width;
            canvas.height = height;
            
            // æ˜¾å¼è®¾ç½® canvas çš„ CSS å°ºå¯¸ï¼Œå¼ºåˆ¶ä¸å†…éƒ¨åˆ†è¾¨ç‡ä¸€è‡´
            // è¿™èƒ½é˜²æ­¢æµè§ˆå™¨å› åœ°å€æ å‡ºç°/æ¶ˆå¤±è€Œè‡ªåŠ¨æ‹‰ä¼¸ canvas å¯¼è‡´å½¢å˜
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        window.addEventListener('resize', resize);
        // åˆå§‹åŒ–æ—¶è°ƒç”¨ä¸€æ¬¡
        resize();

    </script>
</body>
</html>

